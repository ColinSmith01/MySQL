
<#
    MySQL Restore with Progress & Robust Conversion (Updated)
    - Converts .sql.gz and .sql.sql to plain .sql (header-aware for mislabelled gzip)
    - Streams SQL to mysql.exe stdin with progress bar and periodic logs
    - Logs per-DB timings and errors; writes stdout/stderr to F:\Dumps\logs\
    - Hardened cleanup, reliable DDL execution, timeout, and continue-on-error with summary
#>

param(
    [string]$DumpDir = "F:\Dumps",      # Folder containing dumps
    [switch]$Recurse = $false,          # Set -Recurse if files are in subfolders

    # Login path (created via mysql_config_editor; e.g., "restore")
    [string]$LoginPath = "restore",

    # Tools
    [string]$MySqlExe = "mysql",

    # Defaults
    [string]$DefaultCharset = "utf8mb4",
    [string]$Collation = "utf8mb4_0900_ai_ci",

    # Logging
    [string]$LogFile = "F:\Dumps\restore.log",

    # Drop & recreate schema before import
    [switch]$DropAndRecreate = $true,

    # Progress logging granularity (log every N% progress)
    [int]$ProgressLogPercent = 5,

    # Timeout per DB (seconds)
    [int]$WaitTimeoutSec = 900,

    # Stop the whole run on first error
    [switch]$StopOnError = $false
)

function TS { Get-Date -Format "yyyy-MM-dd HH:mm:ss" }
function Write-Log([string]$msg, [string]$level="INFO") {
    $line = "[{0}] [{1}] {2}" -f (TS), $level.ToUpper(), $msg
    Write-Host $line
    Add-Content -Path $LogFile -Value $line
}

# --- Setup ---
if (-not (Test-Path -Path $DumpDir)) { throw "DumpDir not found: $DumpDir" }
New-Item -ItemType File -Path $LogFile -Force | Out-Null

# Per-DB logs folder
$PerDbLogDir = Join-Path $DumpDir "logs"
if (-not (Test-Path $PerDbLogDir)) { New-Item -ItemType Directory -Path $PerDbLogDir -Force | Out-Null }

# Helper: check if a file begins with the gzip magic header 0x1F 0x8B
function Test-IsGzip([string]$path) {
    if (-not (Test-Path -LiteralPath $path)) { return $false }
    try {
        $fs = [System.IO.File]::OpenRead($path)
        try {
            if ($fs.Length -lt 2) { return $false }
            $b1 = $fs.ReadByte()
            $b2 = $fs.ReadByte()
            return ($b1 -eq 0x1F -and $b2 -eq 0x8B)
        } finally { $fs.Dispose() }
    } catch {
        Write-Log "Header check failed for '$path': $($_.Exception.Message)" "WARN"
        return $false
    }
}

# Convert any .sql.gz to .sql and fix .sql.sql names to .sql
function Convert-AllToSql([System.IO.FileInfo[]]$files) {
    $converted = New-Object System.Collections.Generic.List[System.IO.FileInfo]

    foreach ($f in $files) {
        try {
            if ($f.Name.EndsWith(".sql.gz")) {
                $target = [System.IO.Path]::Combine(
                    $f.DirectoryName,
                    $f.Name.Substring(0, $f.Name.Length - 3) # strip ".gz" -> ".sql"
                )
                if (-not $target.EndsWith(".sql")) { $target += ".sql" }

                $isGzip = Test-IsGzip -path $f.FullName
                if ($isGzip) {
                    Write-Log "Decompressing (valid gzip) '$($f.FullName)' -> '$target' ..."
                    $inStream  = [System.IO.File]::OpenRead($f.FullName)
                    try {
                        $gzStream  = New-Object System.IO.Compression.GZipStream(
                            $inStream, [System.IO.Compression.CompressionMode]::Decompress
                        )
                        try {
                            $outStream = [System.IO.File]::Open(
                                $target, [System.IO.FileMode]::Create, [System.IO.FileAccess]::Write
                            )
                            try {
                                $buffer = New-Object byte[] 81920
                                while (($read = $gzStream.Read($buffer, 0, $buffer.Length)) -gt 0) {
                                    $outStream.Write($buffer, 0, $read)
                                }
                            } finally { $outStream.Dispose() }
                        } finally { $gzStream.Dispose() }
                    } finally { $inStream.Dispose() }
                    Write-Log "Decompression complete: '$target'."
                } else {
                    Write-Log "File '$($f.Name)' is NOT gzip (bad/missing magic header). Treating as plain SQL and copying/renaming -> '$target'." "WARN"
                    Copy-Item -LiteralPath $f.FullName -Destination $target -Force
                }
                $converted.Add((Get-Item -LiteralPath $target))
            }
            elseif ($f.Name.EndsWith(".sql.sql")) {
                $target = [System.IO.Path]::Combine(
                    $f.DirectoryName,
                    $f.Name.Substring(0, $f.Name.Length - 4) # strip trailing ".sql"
                )
                Write-Log "Renaming '$($f.FullName)' -> '$target' ..."
                if (Test-Path -LiteralPath $target) {
                    Remove-Item -LiteralPath $target -Force
                    Write-Log "Existing target '$target' removed to allow rename."
                }
                Rename-Item -LiteralPath $f.FullName -NewName ([System.IO.Path]::GetFileName($target))
                $converted.Add((Get-Item -LiteralPath $target))
            }
            elseif ($f.Name.EndsWith(".sql")) {
                $converted.Add($f) # Already plain SQL
            }
            else {
                Write-Log "Skipping unsupported dump type: '$($f.FullName)'" "WARN"
            }
        } catch {
            Write-Log "Conversion failed for '$($f.FullName)': $($_.Exception.Message)" "ERROR"
            throw
        }
    }
    return $converted
}

# Derive DB name from file name (keeps hyphens, skips leading 'aurora', stops at first digit token)
function Get-DbNameFromFile([string]$fileName) {
    $base = $fileName
    if ($base.EndsWith(".sql")) { $base = $base.Substring(0, $base.Length - 4) }
    if ($base.StartsWith("Backup-", [System.StringComparison]::OrdinalIgnoreCase)) {
        $base = $base.Substring(7)
    }

    $tokens = $base.Split('-') | Where-Object { $_ -ne "" }
    $nameTokens = @()
    foreach ($t in $tokens) {
        if ($t -match '^\d') { break }
        if ($nameTokens.Count -eq 0 -and $t -match '^(?i)aurora$') { continue }
        $nameTokens += $t
        if ($nameTokens.Count -ge 4) { break }
    }
    if ($nameTokens.Count -eq 0) { throw "Could not derive database name from '$fileName'." }
    return ($nameTokens -join '-')
}

# Start mysql and stream the SQL file into stdin with progress and error capture
function Import-MySqlWithProgress(
    [string]$MySqlExe, [string]$LoginPath, [string]$DefaultCharset,
    [string]$dbName, [string]$initCmd, [string]$sqlPath,
    [int]$progressStepPercent,
    [int]$waitTimeoutSec,
    [string]$PerDbLogDir
) {
    if (-not (Test-Path -LiteralPath $sqlPath)) { throw "SQL file not found: $sqlPath" }

    $start = Get-Date
    $fileInfo = Get-Item -LiteralPath $sqlPath
    $totalBytes = $fileInfo.Length
    $totalMB = [Math]::Round(($totalBytes / 1MB), 2)

    Write-Log "Begin restore '$dbName' from '$sqlPath' (Size: $totalMB MB) at $($start.ToString('yyyy-MM-dd HH:mm:ss'))"

    # Build process start info (use -D and explicit equals for init-command; safe quoting)
    $psi = New-Object System.Diagnostics.ProcessStartInfo
    $psi.FileName = $MySqlExe
    $psi.Arguments = @(
        "--login-path=`"$LoginPath`"",
        "--default-character-set=`"$DefaultCharset`"",
        "-D `"$dbName`"",
        "--init-command=`"$initCmd`""
    ) -join ' '
    $psi.UseShellExecute = $false
    $psi.RedirectStandardInput = $true
    $psi.RedirectStandardError = $true
    $psi.RedirectStandardOutput = $true
    $psi.CreateNoWindow = $true

    $proc = [System.Diagnostics.Process]::Start($psi)
    if (-not $proc) { throw "Failed to start process '$MySqlExe'." }

    # Prepare per-DB log files
    $dbSlug = $dbName -replace '[^A-Za-z0-9._-]', '_'
    $stderrPath = Join-Path $PerDbLogDir ("{0}.stderr.log" -f $dbSlug)
    $stdoutPath = Join-Path $PerDbLogDir ("{0}.stdout.log" -f $dbSlug)

    # Async readers (typed delegates)
    $stdOutBuilder = New-Object System.Text.StringBuilder
    $stdErrBuilder = New-Object System.Text.StringBuilder

    $handlerOut = [System.Diagnostics.DataReceivedEventHandler]{
        param($sender, $e)
        if ($e.Data) { [void]$stdOutBuilder.AppendLine($e.Data) }
    }
    $handlerErr = [System.Diagnostics.DataReceivedEventHandler]{
        param($sender, $e)
        if ($e.Data) { [void]$stdErrBuilder.AppendLine($e.Data) }
    }

    $proc.add_OutputDataReceived($handlerOut)
    $proc.add_ErrorDataReceived($handlerErr)
    $proc.BeginOutputReadLine()
    $proc.BeginErrorReadLine()

    # Stream the SQL file to mysql stdin with progress updates
    $fs = [System.IO.File]::OpenRead($sqlPath)
    $buffer = New-Object byte[] (1024 * 1024) # 1 MB chunks
    $sentBytes = 0
    $nextLogPercent = $progressStepPercent

    try {
        if ($totalBytes -le 0) {
            Write-Log "SQL file '$sqlPath' is 0 bytes; sending empty input." "WARN"
        } else {
            while (($read = $fs.Read($buffer, 0, $buffer.Length)) -gt 0) {
                $proc.StandardInput.BaseStream.Write($buffer, 0, $read)
                $proc.StandardInput.BaseStream.Flush()
                $sentBytes += $read

                # Progress bar in console
                $pct = [Math]::Round(($sentBytes / [double]$totalBytes) * 100, 1)
                $status = "{0}% ({1} / {2} MB)" -f $pct, ([Math]::Round($sentBytes/1MB,2)), $totalMB
                Write-Progress -Activity "Restoring $dbName" -Status $status -PercentComplete $pct

                # Periodic progress logging to the log file
                if ($pct -ge $nextLogPercent) {
                    Write-Log ("Restore '{0}' progress: {1}% ({2}/{3} MB)" -f $dbName, $pct, ([Math]::Round($sentBytes/1MB,2)), $totalMB)
                    $nextLogPercent += $progressStepPercent
                }
            }
        }
    } finally {
        try { $fs.Dispose() } catch {}
        try { $proc.StandardInput.Close() } catch {}
    }

    # Wait for completion with timeout
    if (-not $proc.WaitForExit($waitTimeoutSec * 1000)) {
        Write-Log "mysql did not exit within $waitTimeoutSec seconds. Killing process…" "ERROR"
        try { $proc.Kill() } catch {}
        throw "Timeout: mysql did not complete for '$dbName'."
    }

    # Safe finalize output capture
    try { $proc.CancelOutputRead() } catch {}
    try { $proc.CancelErrorRead() } catch {}
    try { $proc.remove_OutputDataReceived($handlerOut) } catch {}
    try { $proc.remove_ErrorDataReceived($handlerErr) } catch {}

    $stdout = $stdOutBuilder.ToString()
    $stderr = $stdErrBuilder.ToString()

    # Write per-DB logs
    if ($stdout) { Set-Content -LiteralPath $stdoutPath -Value $stdout -Encoding UTF8 }
    if ($stderr) { Set-Content -LiteralPath $stderrPath -Value $stderr -Encoding UTF8 }

    $end = Get-Date
    $duration = $end - $start
    $secs = [Math]::Max([Math]::Round($duration.TotalSeconds, 2), 0.01)
    $mbps = if ($secs -gt 0) { [Math]::Round($totalMB / $secs, 2) } else { 0 }

    # Count errors heuristically
    $errLines = @()
    if ($stderr) {
        $errLines = $stderr.Split("`n") | Where-Object {
            $_ -match '(?i)\bERROR\b|\bfatal\b|\bsyntax\b|\bduplicate\b|\baccess denied\b|\bunknown database\b'
        }
    }
    $errCount = $errLines.Count

    # Clear progress bar
    Write-Progress -Activity "Restoring $dbName" -Completed

    if ($proc.ExitCode -eq 0 -and $errCount -eq 0) {
        Write-Log ("[OK] '{0}' restored. Completed at {1}. Duration: {2:mm\:ss} (≈{3} MB, {4} MB/s)" -f $dbName, $end.ToString('yyyy-MM-dd HH:mm:ss'), $duration, $totalMB, $mbps)
    } else {
        Write-Log ("[FAIL] '{0}' restore encountered issues. ExitCode={1}, Errors={2}. Completed at {3}. Duration: {4:mm\:ss}" -f $dbName, $proc.ExitCode, $errCount, $end.ToString('yyyy-MM-dd HH:mm:ss'), $duration) "ERROR"

        if ($errCount -gt 0) {
            $preview = ($errLines | Select-Object -First 5) -join " | "
            Write-Log ("Error preview: {0}" -f $preview) "ERROR"
            Write-Log ("Full stderr saved to: {0}" -f $stderrPath) "ERROR"
        }
        if ($stdout) {
            Write-Log ("mysql stdout saved to: {0}" -f $stdoutPath) "INFO"
        }
        throw "Import failed or produced errors for '$dbName' (ExitCode=$($proc.ExitCode), ErrLines=$errCount). See per-DB logs."
    }
}

# Use wildcard in -Path with -Include (so it works without -Recurse)
$gciParams = @{ Path = (Join-Path $DumpDir '*'); File = $true }
if ($Recurse) { $gciParams.Recurse = $true }

# Collect initial dump files (any supported format)
$initialFiles = Get-ChildItem @gciParams -Include *.sql, *.sql.gz, *.sql.sql | Sort-Object FullName

if ($initialFiles.Count -eq 0) {
    Write-Log "No dump files found in $DumpDir (Recurse=$Recurse). Looking for: *.sql, *.sql.gz, *.sql.sql" "WARN"
    $present = Get-ChildItem -Path $DumpDir -Force
    Write-Log ("Contents of {0}: {1}" -f $DumpDir, (($present | Select-Object -ExpandProperty Name) -join ', ')) "INFO"
    exit 0
}

Write-Log "Found $($initialFiles.Count) dump files to convert/import in $DumpDir (Recurse=$Recurse):"
$initialFiles | ForEach-Object { Write-Log " - $($_.FullName)" }

# Convert everything to .sql first
Write-Log "=== Converting all dumps to plain .sql ==="
$convertedFiles = Convert-AllToSql -files $initialFiles

# Deduplicate by FullName (avoid importing the same file twice)
$convertedFiles = $convertedFiles | Sort-Object FullName -Unique

if ($convertedFiles.Count -eq 0) {
    Write-Log "No .sql files available after conversion. Nothing to import." "WARN"
    exit 0
}

Write-Log "=== Ready to import .sql files ==="
$convertedFiles | ForEach-Object { Write-Log " - $($_.FullName)" }

# Literal backtick for quoting DB names in SQL (DDL)
$bt = [char]96  # `

# Track failures
$failures = New-Object System.Collections.Generic.List[System.String]

foreach ($f in $convertedFiles) {
    try {
        $dbName = Get-DbNameFromFile $f.Name
        $dbNameBT = "$bt$dbName$bt"  # backtick-quoted DB name for DDL
        $initCmd = 'SET FOREIGN_KEY_CHECKS=0;'

        Write-Log "=== Restoring database '$dbName' from '$($f.FullName)' ==="

        # Drop & recreate schema (call mysql directly; no cmd.exe)
        if ($DropAndRecreate) {
            $ddl = "DROP DATABASE IF EXISTS $dbNameBT; CREATE DATABASE $dbNameBT CHARACTER SET $DefaultCharset COLLATE $Collation;"
            $ddlArgs = @(
                "--login-path=`"$LoginPath`"",
                "--default-character-set=`"$DefaultCharset`"",
                "-e", $ddl
            )
            & $MySqlExe @ddlArgs | Out-Null
            if ($LASTEXITCODE -ne 0) {
                Write-Log "Pre-create failed for $dbName (ExitCode=$LASTEXITCODE)" "ERROR"
                $failures.Add("$($f.FullName): Pre-create failed (ExitCode=$LASTEXITCODE)")
                if ($StopOnError) { break } else { continue }
            }
            Write-Log "Database '$dbName' dropped & created."
        }

        # Import with progress + error capture
        Import-MySqlWithProgress -MySqlExe $MySqlExe -LoginPath $LoginPath -DefaultCharset $DefaultCharset `
                                 -dbName $dbName -initCmd $initCmd -sqlPath $f.FullName `
                                 -progressStepPercent $ProgressLogPercent -waitTimeoutSec $WaitTimeoutSec -PerDbLogDir $PerDbLogDir

        Write-Log "[OK] '$dbName' restored."
    } catch {
        Write-Log $_.Exception.Message "ERROR"
        $failures.Add("$($f.FullName): $($_.Exception.Message)")
        if ($StopOnError) { break } else { continue }
    }
}

if ($failures.Count -gt 0) {
    Write-Log ("One or more databases failed:`n - " + ($failures -join "`n - ")) "ERROR"
} else {
    Write-Log "All databases restored successfully."
}
